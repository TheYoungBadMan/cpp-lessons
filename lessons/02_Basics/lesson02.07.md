# Изменение в управляющих конструкциях

## Содержание

- [Цикл for-range](#цикл-for-range)
- [Инициализация переменных в операторах ветвления и цикле for-range](#инициализация-переменных-в-операторах-ветвления-и-цикле-for-range)
  - [Инициализация переменных в операторах ветвления](#инициализация-переменных-в-операторах-ветвления)
  - [Инициализация переменных в цикле for-range](#инициализация-переменных-в-цикле-for-range)
- [Расширенные возможности инициализации в C++23](#расширенные-возможности-инициализации-в-c23)

## Цикл `for-range`

В стандарте `C++11` был добавлен новый цикл `for`, который позволяет итерироваться по элементам контейнера. Синтаксис следующий:

```cpp
for (declaration : range) {
    // code
}
```

`declaration` - объявление переменной, которая будет хранить элементы контейнера. Переменная может быть объявлена по значению или по ссылке. `range` - контейнер, по которому будет производиться итерация.

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};

for (auto& elem : vec) {
    std::cout << elem << std::endl;
}
```

В данном примере переменная `elem` будет хранить элементы вектора `vec` по ссылке, что позволяет изменять их.

For-range основан на итераторах, поэтому его можно использовать для любого контейнера, который имеет методы `begin()` и `end()`. По сути, цикл является синтаксическим сахаром для обычного цикла с итераторами:

```cpp
for (auto it = vec.begin(); it != vec.end(); ++it) {
    auto& elem = *it;
    std::cout << elem << std::endl;
}
```

Также, цикл `for` можно использовать для итерации по массивам:

```cpp
int arr[] = {1, 2, 3, 4, 5};

for (auto& elem : arr) {
    std::cout << elem << std::endl;
}
```

## Инициализация переменных в операторах ветвления и цикле `for-range`

### Инициализация переменных в операторах ветвления

В стандарте `C++17` были внесены изменения в операторы ветвления `if` и `switch`. Теперь в них можно использовать инициализацию переменных как в цикле `for`. Синтаксис следующий:

```cpp
if (init-statement; condition) {
     // code
}

switch (init-statement; condition) {
    // cases
}
```

Пример использования:

```cpp
std::unordered_map<int, std::string> map = {
    {1, "one"},
    {2, "two"},
    {3, "three"}
};

if (auto it = map.find(2); it != map.end()) {
    std::cout << it->second << std::endl;
} else {
    std::cout << "Not found" << std::endl;
}
```

### Инициализация переменных в цикле `for-range`

В стандарте `C++20` была добавлена возможность инициализации переменных в цикле `for-range`. Синтаксис следующий:

```cpp
for (init-statement; declaration : range) {
    // code
}
```

`init-statement` - инициализация переменных, которая выполняется перед началом итерации. Пример использования:

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};

for (int i = 0; auto& elem : vec) {
    std::cout << i++ << ": " << elem << std::endl;
}
```

## Расширенные возможности инициализации в `C++23`

В стандарте `C++23` в операторах ветвления и циклах `for`/`for-range` помимо инициализации переменных можно использовать инициализацию синонимов типов. До `C++23` для этих целей разрешалось использовать только синонимы, объявленные с помощью `typedef`.

Пример использования синонима типа в операторе ветвления:

```cpp
template <typename T>
void print(const T& value) {
    if (using U = std::decay_t<T>; std::is_integral_v<U>) {
        std::cout << "Integral: " << value << std::endl;
    } else if (std::is_floating_point_v<U>) {
        std::cout << "Floating point: " << value << std::endl;
    } else {
        std::cout << "Unknown type" << std::endl;
    }
}
```

Пример использования синонима типа в цикле `for-range`:

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};

for (using T = std::vector<int>::value_type; T& elem : vec) {
    std::cout << elem << std::endl;
}
```

Таким образом, `init-statement` в операторах ветвления и циклах `for`/`for-range` может быть любым объявлением переменной или синонима типа.

Объявленная переменная или синоним типа видна только внутри блока соответствующего оператора ветвления или цикла.
