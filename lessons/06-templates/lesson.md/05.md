# Шаблоны с переменным числом аргументов. Fold-выражения (C++17)

## Переменное число аргументов

Шаблоны с переменным числом аргументов позволяют создавать шаблоны функций и классов, которые могут принимать произвольное число аргументов различных типов. Синтаксис шаблонов с переменным числом аргументов в С++ появился в стандарте C++11 в следующем виде:

```cpp
template <typename... Args>
void foo(Args... args) {}
```

В данном примере `Args` - это параметр шаблона, который представляет собой пакет типов данных. Параметр шаблона `Args` может быть пустым, содержать один или несколько типов данных. Параметры шаблона `Args` передаются в функцию `foo` в виде пакета аргументов `args`.

Такая функция может быть вызвана с произвольным числом аргументов:

```cpp
foo(); // Args = {}
foo(1); // Args = {int}
foo(1, "hello", 3.14); // Args = {int, const char*, double}
```

## Оператор `sizeof...`

Оператор `sizeof...` позволяет получить количество аргументов в пакете:

```cpp
template <typename... Args>
void print(Args... args) {
    std::cout << sizeof...(args) << std::endl;
}

print(); // 0
print(1, "hello", 3.14); // 3
```

В данном примере `sizeof...(args)` возвращает количество аргументов в пакете `args`. Если пакет аргументов пустой, то `sizeof...(args)` вернет 0.



## Fold-выражения

Fold-выражения - это нововведение в стандарте C++17, которое позволяет применять бинарные операторы к пакету аргументов. Fold-выражения имеют следующий синтаксис:

```cpp
(... op args) - unary right fold (унарное правоассоциативное свертывание)
(args op ...) - unary left fold (унарное левоассоциативное свертывание)
(pack op ... op init) - binary right fold (бинарное правоассоциативное свертывание)
(init op ... op pack) - binary left fold (бинарное левоассоциативное свертывание)
```

В данном примере `op` - это бинарный оператор, `args` - пакет аргументов, `init` - начальное значение. Важно отметить, что во всем выражении должен быть использован один и тот же бинарный оператор.

Процесс свертывания можно опиcать следующим образом:

- (E op ...) преобразуется в (E1 op (... op (EN-1 op EN) ...)), если свертывание левоассоциативное
- (... op E) преобразуется в (((E1 op E2) op ...) op EN), если свертывание правоассоциативное
- (E op ... op I) преобразуется в (E1 op (... op (EN-1 op (EN op I)))), если свертывание левоассоциативное
- (I op ... op E) преобразуется в ((((I op E1) op E2) op ...) op EN), если свертывание правоассоциативное

Примеры использования унарного свертывания:

```cpp
template <typename... Args>
auto sum(Args... args) {
    return (... + args);
}

int s = sum(1, 2, 3, 4, 5); // s = 15
```

В данном примере выражение `(... + args)` преобразуется в `(((1 + 2) + 3) + 4) + 5`, что равно 15. Хотя оператор `+` является левоассоциативным, в данном случае порядок вычислений не имеет значения, и можно было бы использовать правоассоциативное свертывание `args + ...`.

Вот пример, где выбор свертывания важен:

```cpp
template <typename... Args>
auto sub(Args... args) {
    return (... - args);
}

int s1 = sub(1, 2, 3, 4, 5); // s1 = -13
```

Так как оператор `-` является левоассоциативным, выражение `(... - args)` преобразуется в `(((1 - 2) - 3) - 4) - 5`, что равно -13. Если бы использовалось правоассоциативное свертывание `args - ...`, результат был бы другим: `1 - (2 - (3 - (4 - 5))) = 3`.

Если для унарного свертывания используется пустой пакет аргументов, то только следующие операторы могут быть использованы:

- Оператор `&&`. Значения для пустого пакета будет `true`.
- Оператор `||`. Значения для пустого пакета будет `false`.
- Оператор `,`. Значения для пустого пакета будет `void()`.

Бинарное свертывание полезно, когда часть выражения не является частью пакета аргументов:

```cpp
template <typename... Args>
void print(Args... args) {
    (std::cout << ... << args) << std::endl;
}

print(1, "hello", 3.14); // 1hello3.14
```

В данном примере выражение `(std::cout << ... << args)` преобразуется в `((std::cout << 1) << "hello") << 3.14`, что выводит `1hello3.14`. Это важно, так как часть выражения `std::cout` не является частью пакета аргументов `args`.

Можно модифицировать выражение, чтобы добавить разделители между аргументами:

```cpp
template <typename... Args>
void print(Args... args) {
    ((std::cout << args << ", "), ...) << std::endl;
}

print(1, "hello", 3.14); // 1, hello, 3.14,
```

В данном примере выражение `((std::cout << args << ", "), ...)` преобразуется в `((std::cout << 1 << ", ") << "hello" << ", ") << 3.14 << ", "`, что выводит `1, hello, 3.14,`.