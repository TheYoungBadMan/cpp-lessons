# Пространства имен

## План занятия

1. [Определение](#определение)

2. [Синтаксис объявления пространства имен](#синтаксис-объявления-пространства-имен)
3. [Вложенные пространства имен](#вложенные-пространства-имен)
    - [Пространства имен внутри пространств имен](#пространства-имен-внутри-пространств-имен)
    - [Пространства имен внутри классов/структур](#пространства-имен-внутри-классовструктур)
    - [Пространства имен внутри функций (`C++17`)](#пространства-имен-внутри-функций-c17)
4. [Глобальное пространство имен](#глобальное-пространство-имен)
5. [Анонимные пространства имен](#анонимные-пространства-имен)
6. [Директива `using`](#директива-using)
7. [Псевдонимы пространств имен](#псевдонимы-пространств-имен)
8. [Inline-пространства имен (`C++11`)](#inline-пространства-имен-c11)
9. [Пространства имен `std`](#пространства-имен-std)

**Пространство имен** — это именнованная область, в которой сгруппированы объекты (переменные, функции, классы и т.д.) для избежания конфликтов аналогичных имен.

Из определения следует, что пространства имен позволяют:

1. **Избегать конфликтов имен** между объектами. Можно использовать одинаковые имена в разных пространствах имен, не опасаясь конфликтов.
2. **Логически группировать** связанные между собой сущности (классы, функции, переменные).

Важно отметить, что пространства имен не влияют на производительность программы, так как они реализуются на этапе компиляции и не влияют на исполняемый код.

## Синтаксис объявления пространства имен

Синтаксис объявления пространства имен следующий:

```cpp
namespace имя_пространства {
    // объявления
}
```

Пример:

```cpp
namespace my_namespace {
    int a = 5;
    void foo() {
        std::cout << "Hello, world!" << std::endl;
    }
}
```

Для доступа к объектам внутри пространства имен используется оператор разрешения области видимости `::`:

```cpp
int main() {
    my_namespace::foo();
    std::cout << my_namespace::a << std::endl;
}
```

## Вложенные пространства имен

### Пространства имен внутри пространств имен

Пространства имен могут быть вложены друг в друга, создавая иерархию:

```cpp

namespace outer {
    namespace inner {
        int a = 5;
    }
}
```

Для доступа к объектам во вложенных пространствах имен используется последовательное применение оператора `::`:

```cpp
int main() {
    std::cout << outer::inner::a << std::endl;
}
```

### Пространства имен внутри классов/структур

Хотя язык позволяет помещать namespace внутрь классов или структур, на практике это встречается крайне редко и обычно не рекомендуется:

```cpp
class MyClass {
public:
    namespace inner {
        int a = 5;
    }
};

int main() {
    std::cout << MyClass::inner::a << std::endl;
}
```

*Примечание*: из примера видно, что сами классы и структуры являются пространствами имен, хотя это не подразумевается в явном виде.

### Пространства имен внутри функций (`C++17`)

В стандарте `C++17` появилась возможность объявлять пространства имен внутри функций. Это позволяет ограничить область видимости объектов, объявленных внутри пространства имен, только функцией, в которой они объявлены:

```cpp
void foo() {
    namespace local {
        int a = 5;
    }
    std::cout << local::a << std::endl;
}
```

Использование пространств имен внутри функций удобно, если нужно объявить объекты, которые используются только внутри функции, хотя это редко используется на практике.

## Глобальное пространство имен

Все объекты, объявленные вне пространства имен, находятся в **глобальном пространстве имен**. Это пространство имен не имеет имени и доступно по умолчанию.

Пример:

```cpp
int a = 5;

int main() {
    std::cout << a << std::endl;
}
```

Если необходимо получить доступ к объектам из глобального пространства имен внутри другого пространства имен или области видимости, используется оператор `::` без указания имени пространства имен:

```cpp
int a = 5;

namespace my_namespace {
    int a = 10;
    void foo() {
        int a = 15;
        std::cout << ::a << std::endl; // 5
    }
}
```

## Анонимные пространства имен

***Анонимные пространства*** имен не имеют имени и объявляются следующим образом:

```cpp

namespace {
    int a = 5;
}

int main() {
    std::cout << a << std::endl;
}
```

Смысл анонимного пространства в том, что все его объекты имеют внутреннее связывание (`internal linkage`), то есть видны только в пределах данного файла (`translation unit`). Ранее в `C` для похожей цели использовали `static` на глобальном уровне, но в `C++` предпочитают анонимные пространства имен.

Пример использования анонимного пространства имен:

```cpp
// file.cpp
namespace {
    int a = 5;
}

// main.cpp

extern int a; // Ошибка компиляции: a не видно вне файла file.cpp

int main() {
    std::cout << a << std::endl; // Ошибка
}
```

## Директива `using`

Для упрощения доступа к объектам внутри пространства имен можно использовать ключевое слово `using`. Оно позволяет использовать объекты без указания имени пространства имен.

Пример использования:

```cpp
namespace my_namespace {
    int a = 5;
    void foo() {
        std::cout << "Hello, world!" << std::endl;
    }
}

int main() {
    using namespace my_namespace;
    foo();
    std::cout << a << std::endl;
}
```

По своей сути, использование `using namespace` равносильно извлечению всех объектов из пространства имен и вставке их в текущую область видимости.

Также можно использовать ключевое слово `using` для доступа к конкретному объекту:

```cpp
int main() {
    using my_namespace::foo;
    foo();
}
```

Использование `using namespace` бывает полезным, если часто приходится обращаться к объектам из одного пространства имен или если имена объектов в пространстве имен слишком длинные из-за вложенности.

Следует быть осторожным с использованием ключевого слова `using`, так как это может привести к конфликтам, если в текущей области видимости уже есть объекты с такими же именами. Пример конфликта:

```cpp
namespace my_namespace {
    int a = 5;
}

int main() {
    int a = 10;
    using namespace my_namespace;
    std::cout << a << std::endl; // Конфликт имен: a из my_namespace или a из main?
}
```

## Псевдонимы пространств имен

Если пространство имен имеет слишком длинное имя или содержит глубокую вложенность, его можно сократить, создав псевдоним следующим образом:

```cpp
namespace outer {
    namespace inner {
        int a = 5;
    }
}

namespace oi = outer::inner;

int main() {
    std::cout << oi::a << std::endl;
}
```

## Inline-пространства имен (`C++11`)

*Inline-пространства имен* позволяют версионировать код, при этом объекты "встроенного" пространства имен видны так, как будто они объявлены во внешнем пространстве имен:

```cpp
namespace my_namespace {
    inline namespace v1 {
        void foo() {}
    }
    namespace v2 {
        void foo() {}
    }
}

int main() {
    my_namespace::foo(); // вызовется foo из v1
    my_namespace::v2::foo(); // вызовется foo из v2
}
```

Это позволяет обеспечить обратную совместимость кода при добавлении новых функций или изменении старых.

## Пространства имен `std`

Все объекты стандартной библиотеки C++ (например, `std::cout`, `std::string`) находятся в пространстве имен `std`.

```cpp
#include <iostream>

int main() {
    std::cout << "Hello, world!" << std::endl;
}
```

Для упрощения доступа к объектам из стандартной библиотеки можно использовать директиву `using namespace`:

```cpp
#include <iostream>

using namespace std;

int main() {
    cout << "Hello, world!" << endl;
}
```

Однако использование `using namespace std` в заголовочных файлах не рекомендуется, так как это может ломать чужой код, который подключает этот заголовочный файл.