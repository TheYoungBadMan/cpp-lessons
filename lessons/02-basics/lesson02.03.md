# Новые типы данных в `C++`

В языке программирования C++ есть несколько новых типов данных, которых нет в языке C. Рассмотрим их подробнее.

## Тип `bool`

Тип `bool` представляет собой логическое значение, которое может быть либо `true` (истина), либо `false` (ложь). В языке C++ логические значения `true` и `false` являются ключевыми словами.

```cpp
#include <iostream>

int main() {
    bool a = true;
    bool b = false;
    std::cout << "a = " << a << ", b = " << b << std::endl;
    return 0;
}
```

Тип `bool` используется в условных операторах, циклах и других конструкциях, где требуется логическое значение. Этот тип данных занимает 1 байт в памяти и считается целочисленным типом, поэтому он легко преобразуется в другие целочисленные типы.

## Тип `std::string`

Хотя стандарт C++ не содержит строкового типа данных, в стандартной библиотеке C++ есть класс `std::string`, который предоставляет удобный способ работы со строками. Для использования этого класса необходимо подключить заголовочный файл `<string>`.

```cpp
#include <iostream>
#include <string>

int main() {
    std::string s = "Hello, world!";
    std::cout << s << std::endl;
    return 0;
}
```

Класс `std::string` предоставляет множество методов для работы со строками, таких как конкатенация, поиск подстроки, сравнение строк и другие.

Подробнее о классе `std::string` можно узнать в [документации](https://en.cppreference.com/w/cpp/string/basic_string).

*Примечание:* `C++` также поддерживает стандартные строки `char*`, но использование `std::string` предпочтительнее, так как он обеспечивает безопасность и удобство работы.

## `nullptr` и `std::nullptr_t`

Ранее в `C` для обозначения нулевого указателя использовался макрос `NULL`, который раскрывался как `typedef (void*) 0`. В С++ использование `NULL` не рекомендуется, так как могут возникнуть проблемы с перегрузкой функций. Пример:

```cpp
#include <cstdlib>

void foo(int) {}

void foo(double) {}

int main() {
    foo(NULL); // Ошибка компиляции: call of overloaded 'foo(NULL)' is ambiguous
    return 0;
}
```

Для решения этой проблемы в `C++11` был введен литерал `nullptr`, который представляет собой нулевой указатель. Как и `NULL`, `nullptr` легко преобразуется в любой указатель, но не преобразуется в целочисленные типы. Пример:

```cpp
void foo(int*) {}

void foo(int) {}

int main() {
    foo(nullptr); // Вызовется функция foo(int*)
    return 0;
}
```

Стандарт C++ также определяет тип `std::nullptr_t`, который используется для определения `nullptr`. Этот тип данных является пустым и не имеет значений, кроме `nullptr`. Стандарт определяет его следующим образом:

```cpp
namespace std {
    typedef decltype(nullptr) nullptr_t;
}
```

## Безопасные перечисления (`enum class`)

Перечисления в языке `C` не являются типами данных, а просто списками именованных констант. По стандарту, перечисления в `C` не имеют области видимости и ведут себя как целочисленные типы. Это может привести к двум проблемам:

1. Неявные преобразования между перечислениями и целыми числами.
2. Конфликты имен между перечислениями.

В `C++` перечисления уже являются полноценными типами данных, но схожи с перечислениями из `C`. Для решения перечисленных проблем в `C++11` были введены безопасные перечисления (`enum class`), которые являются типами данных с областью видимости.

```cpp

enum class Color {
    Red,
    Green,
    Blue
};

int main() {
    Color c = Color::Red;
    return 0;
}
```

Доступ к элементам перечисления осуществляется через оператор `::`. Это
позволяет избежать конфликтов имен между перечислениями. Также перечисления `enum class` неявно не преобразуются в целые числа, что позволяет избежать ошибок в программе:

```cpp
int main() {
    Color c = Color::Red;
    int i = c; // Ошибка компиляции: cannot convert 'Color' to 'int' in initialization
    return 0;
}
```

## Структуры и классы

В языке `C` структуры являются одними из основных средств для организации данных, но они позволяли только хранить данные. В `C++` помимо структур появились классы, которые позволяют хранить данные и методы для работы с ними.

```cpp

struct Point {
    int x;
    int y;

    Point(int x, int y) : x(x), y(y) {}

    double distance() {
        return sqrt(x * x + y * y);
    }
};

class Circle {
public:
    Circle(int x, int y, int r) : x(x), y(y), r(r) {}
    double area() {
        return 3.14 * r * r;
    }
private:
    int x, y, r;
};

int main() {
    Point p(3, 4);
    std::cout << p.distance() << std::endl;

    Circle c(0, 0, 5);
    std::cout << c.area() << std::endl;
    return 0;
}
```

Структуры и классы в `C++` позволяют создавать пользовательские типы данных, которые могут содержать в себе данные и функции для работы с ними. Они в большей степени схожи, но имеют несколько отличий, связанных с областью видимости и наследованием.

Подробнее о структурах и классах поговорим в соответствующих разделах.

*Примечание:* В `C` имя структуры не является типом данных, поэтому при объявлении переменной необходимо с имени структуры использовать ключевое слово `struct`. В `C++` имя структуры или класса является типом данных, поэтому ключевое слово `struct` или `class` не требуется.

*Примечание:* Объединения (`union`) в `C++` также как и структуры/классы могут содержать методы и конструкторы.
