# Выделение памяти в `C++`

## Совместимость с выделением памяти из `C`

`C++` является надмножеством языка `C`, что означает, что все программы на `C` являются программами на `C++`. Это означает, что `C++` поддерживает все возможности языка `C`, включая работу с указателями и динамическое выделение памяти, в частности функции `malloc` и `free`.

```cpp
#include <cstdlib>

int main() {
    int* a = (int*)malloc(sizeof(int));
    *a = 5;
    free(a);
    return 0;
}
```

Однако в `C++` есть свои средства для работы с памятью, которые являются более безопасными и удобными, чем функции `malloc` и `free`.

## Оператор `new`

Оператор `new` позволяет выделить память для объекта в динамической памяти. Синтаксис оператора `new` следующий:

```cpp
type *ptr = new type;
```

В отличие от `malloc`, оператор `new` возвращает указатель на объект, а не на область памяти. Это означает, что при использовании `new` не нужно явно приводить тип указателя. Если объект является примитивом, то его значение будет инициализировано нулевым значением. Если же объект является пользовательским типом, то для него может быть вызван конструктор по умолчанию или конструктор с параметрами.

```cpp

struct A {
    int x;
    A() : x(0) {}
    A(int x) : x(x) {}
};

int main() {
    A* a = new A(5); // Вызовется конструктор A(int)
    A* b = new A; // Вызовется конструктор A()
    delete a;
    delete b;
    return 0;
}
```

Очевидно, что при использовании `new` с пользовательскими типами данных, соответствующие конструкторы должны быть определены.

## Оператор `delete`

Оператор `delete` позволяет освободить память, выделенную оператором `new`. Синтаксис оператора `delete` следующий:

```cpp
delete ptr;
```

Если `ptr` ссылается на пользовательский тип данных, то для него будет вызван деструктор. Но если `ptr` ссылается на примитивный тип данных, то деструктор не будет вызван (т.к. примитивные типы данных не имеют деструкторов). В частности, если `ptr` ссылается на другой указатель, то деструктор не будет вызван для объекта, а значит не будет освобождена память, выделенная для него.

```cpp
int main() {
    int* ptr1 = new int;
    int** ptr2 = new int*(ptr1);
    delete ptr2; // Память для ptr1 не будет освобождена
    return 0;
}
```

При использовании `delete` с нулевым указателем имеет нулевой эффект, поэтому является безопасным.

Важно помнить, что оператор `delete` не удаляет сам объект, а лишь освобождает память, выделенную под него. После вызова `delete` указатель становится недействительным, и его использование приведет к неопределенному поведению.

## Оператор `new[]` и `delete[]`

Оператор `new[]` позволяет выделить память для массива объектов в динамической памяти. Синтаксис оператора `new[]` следующий:

```cpp
type *ptr = new type[size];
```



Оператор `delete[]` позволяет освободить память, выделенную оператором `new[]`. Синтаксис оператора `delete[]` следующий:

```cpp
delete[] ptr;
```

Как и обычный `delete`, `delete[]` вызывает деструкторы для каждого элемента массива и имеет нулевой эффект при передаче нулевого указателя.
