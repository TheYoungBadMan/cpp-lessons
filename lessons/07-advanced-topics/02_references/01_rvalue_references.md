# Понятие rvalue-ссылок. Семантика перемещения

## Rvalue-ссылки

Rvalue-ссылки - это новый вид ссылок, появившийся в C++11. Они позволяют передавать временные объекты в функции без копирования. Rvalue-ссылки обозначаются двумя амперсандами `&&`. Пример:

```cpp
int&& a = 5; // a - rvalue-ссылка
// раньше пришлось бы использовать const lvalue-ссылку
// const int& a = 5;
```

Как и lvalue-ссылки, rvalue-ссылки обязаны быть инициализированы, но инициализировать их можно только временными объектами. Пример:

```cpp
int a = 5;
int&& b = a; // Ошибка компиляции (cannot bind rvalue reference of type 'int&&' to lvalue of type 'int')
```

Для того чтобы проинициализировать rvalue-ссылку с помощью lvalue, необходимо использовать функцию `std::move` из заголовочного файла `<utility>`. Пример:

```cpp
#include <utility>

int a = 5;
int&& b = std::move(a); // Теперь b - rvalue-ссылка на объект a
```

В остальном rvalue-ссылки работают так же, как и lvalue-ссылки. С помощью них можно изменять состояние объекта, на который они указывают, но нельзя менять объект, на который они указывают. Пример:

Если функция принимает rvalue-ссылку, это означает, что она может принимать временный объект или результат функции `std::move`. Пример:

```cpp
#include <iostream>

void foo(int&& a) {}

int main() {
    foo(5); // Передача временного объекта
    int a = 5;
    foo(std::move(a)); // Передача объекта a после применения std::move
}
```

Если в функции, принимающей rvalue-ссылку, необходимо вызвать другую функцию, которая также принимает rvalue-ссылку, то необходимо повторно использовать `std::move`. Пример:

```cpp

void foo(int&& a) {
	bar(std::move(a)); // Передача rvalue-ссылки
}

void bar(int&& a) {}

int main() {
	foo(5);
}
```

Хотя в функции `foo` тип аргумента `a` - rvalue-ссылка, внутри функции он является lvalue (так как у него есть имя), поэтому для передачи его в функцию `bar` необходимо повторно использовать `std::move`.

Rvalue-ссылки могут быть константными, но на практике это не имеет смысла, так как rvalue-ссылки обычно используются для перемещения объектов, а не для их копирования.

## Мотивация

До С++11 в языке единственный способ передать объект в функцию без копирования - это передать его с помощью lvalue ссылки (или указателя). Если объект временный, то необходимо было использовать константную ссылку. В определенных случаях это приводило к необходимости создавать копии объектов, что не всегда было эффективно при работе с временными объектами. Приведем пример:

```cpp
#include <iostream>

struct A
{
    A() { ... };
};

struct B
{
    B(const A& a) : a(a) { ... }; // Повторное копирование объекта (выделение ресурсов, копирование данных)

    A a;
};

int main()
{
    B b(A()); // Создается временный объект A
}
```

При создании объекта `b` происходит предварительное создание временного объекта `A`, который после вызова конструктора `B` будет уничтожен. При этом в конструкторе `B` происходит копирование временного объекта `A` в поле `a`. Возникает вопрос: зачем копировать объект, который вскоре будет уничтожен, если можно просто "перенести" его в объект `b`? Для решения этой проблемы и были введены rvalue-ссылки.

## Семантика перемещения

Второй важной особенностью rvalue-ссылок является семантика перемещения (move semantics). Семантика перемещения позволяет "перемещать" ресурсы из одного объекта в другой, что может быть гораздо эффективнее, чем копирование. Для перемещения объекта используется функция `std::move`, которая преобразует lvalue в rvalue. Пример

```cpp
#include <iostream>

struct A
{
    A() { ... };
    A(const A& a) : data(a.data) { ... }; // Конструктор копирования
    A(A&& a) : data(std::move(a.data)) { ... }; // Конструктор перемещения

    std::string data; // тяжеловесные данные
};

int main()
{
    A a;
    A b = std::move(a); // Перемещение данных из a в b
}
```

В данном примере при перемещении объекта `a` в объект `b` происходит перемещение данных из `a` в `b`, а не их копирование. После перемещения объект `a` остается в "валидном, но неопределенном" состоянии, и его использование может привести к неопределенному поведению. Поэтому после перемещения объекта его необходимо "обнулить" или уничтожить. Пример:

```cpp
A::A(A&& a) : data(std::move(a.data))
{
    a.data.clear(); // Пример "обнуления" объекта
}
```

Семантика перемещения позволяет эффективно работать с временными объектами и улучшает производительность программы, позволяя избегать копирования объектов. Для этого необходимо правильно реализовывать конструкторы перемещения и операторы присваивающего перемещения. По умолчанию компилятор генерирует их самостоятельно. Если поля объекта являются примитивными типами или имеют правильно реализованные конструкторы перемещения, то необходимость в реализации конструкторов перемещения и операторов присваивающего перемещения отпадает (правило "Rule of Zero"). В противном случае стандартные конструкторы перемещения и операторы присваивающего перемещения не гарантируют эффективное перемещение объектов (объекты могут оставаться в "невалидном" состоянии после перемещения). Пример реализации семантики перемещения для кастомного класса `vector`:

```cpp
template <typename T>
class vector {
public:
    vector() : data(nullptr), size(0), capacity(0) {}

    explicit vector(size_t size) : data(new T[size]), size(size), capacity(size) {}

    vector(const vector& other) : data(new T[other.capacity]), size(other.size), capacity(other.capacity) {
        std::copy(other.data, other.data + other.size, data);
    }

    vector(vector&& other) : data(other.data), size(other.size), capacity(other.capacity) {
        other.data = nullptr; // "Обнуление" объекта other
        other.size = 0;
        other.capacity = 0;
    }

    ~vector() {
        delete[] data;
    }

    vector& operator=(const vector& other) {
        if (this != &other) { // Проверка на самоприсваивание
            delete[] data;
            data = new T[other.capacity];
            size = other.size;
            capacity = other.capacity;
            std::copy(other.data, other.data + other.size, data);
        }
        return *this;
    }

    vector& operator=(vector&& other) {
        if (this != &other) { // Проверка на самоприсваивание
            delete[] data;
            data = other.data;
            size = other.size;
            capacity = other.capacity;
            other.data = nullptr; // "Обнуление" объекта other
            other.size = 0;
            other.capacity = 0;
        }
        return *this;
    }

private:
    T* data;
    size_t size;
    size_t capacity;
};

int main() {
    vector<int> a(10);
    vector<int> b = std::move(a); // Перемещение данных из a в b с помощью конструктора перемещения
    vector<int> c;
    c = std::move(b); // Перемещение данных из b в c с помощью оператора присваивающего перемещения
}
```

## Об функции std::move

Функция `std::move` просто преобразует lvalue в rvalue, не перемещая данные. Она не является магической функцией, которая перемещает данные из одного объекта в другой. Пример ее реализации:

```cpp
template <typename T>
constexpr std::remove_reference_t<T>&& move(T&& t) noexcept {
	return static_cast<std::remove_reference_t<T>&&>(t);
}
```

Здесь `std::remove_reference_t<T>` удаляет ссылку из типа `T`, а `static_cast<std::remove_reference_t<T>&&>(t)` преобразует lvalue `t` в rvalue (если `T` не является ссылкой, то эффекта не будет). Использование `std::move` не означает, что объект будет перемещен, это позволяет связать lvalue с rvalue-ссылкой, что в дальнейшем позволяет вызывать нужные перегруженные функции, конструкторы и операторы.

Остается один интересный момент: выше было сказано, что для того чтобы проинициализировать rvalue-ссылку с помощью lvalue, необходимо использовать функцию `std::move`. Если функция принимает lvalue, то почему в сигнатуре функции указан тип rvalue-ссылки? Дело в том, что `std::move` - это шаблонная функция, а параметр T&& в шаблоне не является rvalue-ссылкой, это универсальная ссылка (forwarding reference). Подробнее о них можно прочитать в соответствующем разделе.
